/*------------------------------------------------------*/
/* blifrtl2bdnet.c ---					*/
/*							*/
/*   Read a netlist .blif file generated by "abc" after	*/
/*   standard cell mapping, and rewrite it as a BDNET	*/
/*   format file.  Replace all ".latch" statements with	*/
/*   a generic gate called "DFFDEFAULT" that will be	*/
/*   replaced in the next step by the actual DFF gate	*/
/*   depending on the initial reset condition.		*/	
/*							*/
/*	blifrtl2bdnet <blif_file>			*/
/*							*/
/*   Output is to stdout.				*/
/*------------------------------------------------------*/

#define DEBUG 1

#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <malloc.h>
#include <stdlib.h>

// Define states
#define HEADER_STUFF	0x0001
#define MODULE_VALID	0x0002
#define MAIN_BODY	0x0004
#define IO_SIGNAL	0x0008
#define LATCH		0x0010
#define GATE		0x0020
#define GATE_PINS	0x0040

//-------------------------------------------------------------------
// Main routine
//-------------------------------------------------------------------

int
main(int argc, char *argv[])
{
    FILE *fsource = NULL;	/* BLIF source */
    char *xp, *fptr, *token, *eptr;
    char locfname[512];
    char linebuf[2048];
    const char *toklist;
    int state;
    char linecont;

    char *latch_input = NULL;
    char *latch_output = NULL;
    char *latch_clock = NULL;

    if (argc != 2) {
	fprintf(stderr, "Usage: blifrtl2bdnet <blif_file>\n");
	exit(1);
    }

    /* If argv[1] does not have a .blif extension, make one */

    xp = strrchr(argv[1], '.');
    if (xp != NULL)
	snprintf(locfname, 511, "%s", argv[1]);
    else
	snprintf(locfname, 511, "%s.blif", argv[1]);

    fsource = fopen(locfname, "r");
    if (fsource == NULL) {
	fprintf(stderr, "Error:  No such file or cannot open file \"%s\"\n",
			locfname);
	exit(1);
    }

    toklist = " \t\n";
    state = HEADER_STUFF;
    linecont = 0;

    fgets(linebuf, 2047, fsource);
    fptr = linebuf;

    while (1) {
	token = strtok(fptr, toklist);

	while (token != NULL) {

	    if (!strncmp(token, "#", 1)) {
		break;		// Comment, forget rest of line
	    }
	    else if (!strcmp(token, ".default_input_arrival")) {
		break;		// Ignore this line, too
	    }
	    else if (!strcmp(token, "\\")) {
		linecont = 1;
		break;		// But wait, there's more!
	    }
	    else if ((eptr = strchr(token, '\\')) != NULL) {
		if (*(eptr + 1) == '\0') {
		    *eptr = '\0';
		    linecont = 1;
		}
	    }

	    switch (state) {
		case HEADER_STUFF:
		    if (!strcmp(token, ".model")) {
			state = MODULE_VALID;
		    }
		    break;

		case MODULE_VALID:
		    fprintf(stdout, "MODEL \"%s\";\n\n", token);
		    state = MAIN_BODY;
		    break;

		case MAIN_BODY:
		    if (!strcmp(token, ".inputs")) {
			fprintf(stdout, "INPUT");
			state = IO_SIGNAL;
			break;
		    }
		    else if (!strcmp(token, ".outputs")) {
			fprintf(stdout, "OUTPUT");
			state = IO_SIGNAL;
			break;
		    }
		    else if (!strcmp(token, ".latch")) {
			state = LATCH;
			break;
		    }
		    else if (!strcmp(token, ".gate")) {
			state = GATE;
			break;
		    }
		    else if (!strcmp(token, ".end")) {
			state = HEADER_STUFF;	// Just keep reading to EOF
			break;
		    }
		    break;

		case IO_SIGNAL:
		    // Hack to go along with vmunge.tcl. . .
		    if (strncmp(token, "xloopback_", 10))
			fprintf(stdout, "\n\t\"%s\" : \"%s\"", token, token);
		    break;

		case LATCH:
		    if (latch_input == NULL)
			latch_input = strdup(token);
		    else if (latch_output == NULL)
			latch_output = strdup(token);
		    else if (latch_clock == NULL) {
			if (strcmp(token, "re"))
			    latch_clock = strdup(token);
		    }
		    else {
			fprintf(stdout, "INSTANCE \"DFFDEFAULT\":\"physical\"\n");
			fprintf(stdout, "\t\"DDEFAULT\"   : \"%s\";\n", latch_input);

			// Hack to go along with vmunge.tcl. . .
			if (!strncmp(latch_clock, "xloopback_in_", 13))
			    fprintf(stdout, "\t\"CDEFAULT\" : \"%s\";\n",
					latch_clock + 13);
			else
			    fprintf(stdout, "\t\"CDEFAULT\" : \"%s\";\n", latch_clock);
			fprintf(stdout, "\t\"QDEFAULT\"   : \"%s\";\n\n", latch_output);
		    }
		    break;

		case GATE:
		    fprintf(stdout, "INSTANCE \"%s\":\"physical\"\n", token);
		    state = GATE_PINS;
		    break;

		case GATE_PINS:
		    eptr = strchr(token, '=');
		    if (eptr != NULL) {
			*eptr = '\0';

			// Hack to go along with vmunge.tcl. . .
			if (!strncmp(eptr + 1, "xloopback_out_", 14))
			    fprintf(stdout, "\t\"%s\" : \"%s\";\n", token, eptr + 15);
			else
			    fprintf(stdout, "\t\"%s\" : \"%s\";\n", token, eptr + 1);
			*eptr = '=';
		    }
		    break;

		default:
		    break;
	    }

	    // Proceed to next token
	    token = strtok(NULL, toklist);
	}

	if (linecont == 1) {
	    linecont = 0;
	}
	else
	{
 	    switch(state) {
		case LATCH:
		    if (latch_input) free(latch_input);
		    if (latch_output) free(latch_output);
		    if (latch_clock) free(latch_clock);
		    latch_input = NULL;
		    latch_output = NULL;
		    latch_clock = NULL;
		    state = MAIN_BODY;
		    break;

		case GATE_PINS:
		    fprintf(stdout, "\n");
		    state = MAIN_BODY;
		    break;

		case IO_SIGNAL:
		    fprintf(stdout, ";\n\n");
		    state = MAIN_BODY;
		    break;

		case GATE:
		    fprintf(stderr, "Gate without pins!\n");
		    break;

		case MODULE_VALID:
		    fprintf(stderr, "Module without name!\n");
		    break;
	    }
	}

	if (fgets(linebuf, 2047, fsource) == NULL)
	    break;
    }
    fclose(fsource);

    if (state != HEADER_STUFF)
	fprintf(stderr, "Module without end statement!\n");

    fprintf(stdout, "ENDMODEL;\n");

    return 0;
}
