/*--------------------------------------------------------------*/
/* vesta.c ---							*/
/*								*/
/*	This file reads two files:  (1) A verilog netlist file	*/
/*	of a circuit (structural verilog, that is, gate-level	*/
/*	information only), and (2) a liberty format file 	*/
/*	containing timing information for the standard cell 	*/
/*	macros instantiated in the verilog netlist.  In		*/
/*	addition, it may take an optional third file containing	*/
/*	information about the resistance and capacitance of the	*/
/*	wiring (see below).					*/
/*								*/
/*	Options are supplied as command-line arguments:		*/
/*								*/
/*		-d <delay_file>	Wiring delays (see below)	*/
/*		-p <value>  	Clock period, in ps		*/
/*								*/
/*	Currently the only output this tool generates is a	*/
/*	list of paths with negative slack.  If no paths have	*/
/*	negative slack, then the 20 paths with the smallest	*/
/*	positive slack are output, following a "success"	*/
/*	message.  If no clock period is supplied, then the	*/
/*	clock period is set to equal the delay of the longest	*/
/*	delay path, and the 20 paths with the smallest positive	*/
/*	slack are output, following a statement indicated the	*/
/*	computed minimum clock period.				*/
/*--------------------------------------------------------------*/

/*--------------------------------------------------------------*/
/*	Wiring delay file:					*/
/*	For qflow, the wiring delay is generated by the tool	*/
/*	"def2delays".  The file format is as follows:		*/
/*								*/
/*	<net_name>						*/
/*	<output_terminal> [<net_capacitance>]			*/
/*	<input_terminal_1> <delay_1>				*/
/*	...							*/
/*	<input_terminal_N> <delay_N>				*/
/*								*/
/*	Optional value <net_capacitance> is in fF		*/
/*	Values <delay_i> are in ps				*/
/*--------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <errno.h>
#include <stdarg.h>
 
#define LIB_LINE_MAX  65535

int fileCurrentLine;

// Multiple-use definition
#define	UNKNOWN		-1

// Sections of liberty file
#define INIT		0
#define LIBBLOCK	1
#define CELLDEF		2
#define PINDEF		3
#define FLOPDEF		4
#define LATCHDEF	5
#define TIMING		6

// Sections of verilog file
#define MODULE		0
#define IOLIST		1
#define GATELIST	2
#define INSTANCE	3
#define INSTPIN		4
#define PINCONN		5

// Pin types (these are masks---e.g., a pin can be an INPUT and a CLOCK)
#define INPUT		0x01	// The default
#define OUTPUT		0x02
#define DFFCLK		0x04
#define DFFIN		0x08	// Flop input
#define DFFOUT		0x10	// Flop output
#define DFFSET		0x20	// Flop set (preset)
#define DFFRST		0x40	// Flop reset (clear)
#define LATCHIN		0x80	// Latch input
#define LATCHEN		0x100	// Latch enable

#define IOMASK		0x03
#define DFFMASK		0x7c
#define LATCHMASK	0x180

// Pin sense
#define SENSE_NONE	0	// Non-unate
#define SENSE_POSITIVE	1	// Positive-unate
#define SENSE_NEGATIVE	2	// Negative-unate

// Function translation
#define GROUPBEGIN	1
#define GROUPEND	2
#define SIGNAL		3
#define OPERATOR	4
#define XOPERATOR	5
#define SEPARATOR	6

// Net types
#define	NET		0x00	// Ordinary net (default)
#define	CLOCK		0x01	// Clock net (path start)
#define OUTTERM		0x02	// Module output
#define	ASYNC		0x04	// Asynchronous set/reset
#define TERMINAL	0x08	// DFF input (path terminal)
#define LATCHTERM	0x10	// Latch input (dependent path terminal)
#define ENABLE		0x20	// Latch enable (path start)

// Cell types
#define GATE		0x00	// Combinatorial gate (default)
#define DFF		0x01	// Flip-flop (shared bit field)
#define CLK_SENSE_MASK	0x02	// Clock edge mask (0=positive, 1=negative)
#define RST_MASK	0x04	// Reset mask (0=no reset, 1=reset)
#define RST_SENSE_MASK	0x08	// Reset edge mask (0=positive, 1=negative)
#define SET_MASK	0x10	// Set mask (0=no set, 1=set)
#define SET_SENSE_MASK	0x20	// Set edge mask (0=positive, 1=negative)
#define LATCH		0x40	// Latch type
#define EN_SENSE_MASK	0x80	// Latch enable edge mask (0=positive, 1=negative)

// Some names for cell types based on masks

#define DFFCP		0x01	// Pos clock
#define DFFCN		0x03	// Neg clock
#define DFFCPRP		0x05	// Pos clock, Pos reset
#define DFFCNRP		0x07	// Neg clock, Pos reset
#define DFFCPRN		0x0d	// Pos clock, Neg reset
#define DFFCNRN		0x0f	// Neg clock, Neg reset
#define DFFCPSP		0x11	// Pos clock, Pos set
#define DFFCNSP		0x13	// Neg clock, Pos set
#define DFFCPRPSP	0x15	// Pos clock, Pos reset, Pos set
#define DFFCNRPSP	0x17	// Neg clock, Pos reset, Pos set
#define DFFCPRNSP	0x1d	// Pos clock, Neg reset, Pos set
#define DFFCNRNSP	0x1f	// Neg clock, Neg reset, Pos set
#define DFFCPSN		0x31	// Pos clock, Neg set
#define DFFCNSN		0x33	// Neg clock, Neg set
#define DFFCPRPSN	0x35	// Pos clock, Pos reset, Neg set
#define DFFCNRPSN	0x37	// Neg clock, Pos reset, Neg set
#define DFFCPRNSN	0x3d	// Pos clock, Neg reset, Neg set
#define DFFCNRNSN	0x3f	// Neg clock, Neg reset, Neg set

/*--------------------------------------------------------------*/
/* Liberty file database					*/
/*--------------------------------------------------------------*/

// Types of array

// Array type 1:  Propagation time
#define OUTPUT_CAP		0	
#define TRANSITION_TIME		1

// Array type 2:  Setup, hold, recovery, removal times
#define RELATED_TIME		2
#define CONSTRAINED_TIME	3

typedef struct _lutable *lutableptr;

typedef struct _lutable {
    char *name;
    char invert;	// 0 if times x caps, 1 if caps x times
    int  var1;		// Type of array in index1
    int  var2;		// Type of array in index2
    int  size1;		// Number of entries in time array
    int  size2;		// Number of entries in cap (or constrained timing) array
    union {
        double *times;	// Time array (units ps)
        double *rel;	// Related pin transition time array (units ps)
    } idx1;
    union {
        double *caps;	// Cap array (units fF)
        double *cons;	// Constrained pin transition time array (units ps)
    } idx2;
    double *values;	// Matrix of values (used locally, not for templates)
    lutableptr next;
} lutable;

typedef struct _pin *pinptr;
typedef struct _cell *cellptr;

typedef struct _pin {
    char *name;
    short type;

    double capr;	// Capacitance for rising input
    double capf;	// Capacitance for falling input (optional)

    short sense;	// Sense (positive-unate, negative-unate, non-unate)
    lutable *propdelr;	// Reference table for rising output prop delay relative to driver
    lutable *propdelf;	// Reference table for falling output prop delay relative to driver
    lutable *transr;	// Reference table for transition rise time
    lutable *transf;	// Reference table for transition fall time

    cellptr refcell;	// Pointer back to parent cell

    pinptr next;
} pin;

typedef struct _cell {
    short type;
    char *name;
    char *function;
    pin	 *pins;		/* List of input pins with timing info */
    double area;
    double maxtrans;	/* Maximum transition time */
    double maxcap;	/* Maximum allowable load */
    cellptr next;
} cell;

/*--------------------------------------------------------------*/
/* Verilog netlist database					*/
/*--------------------------------------------------------------*/

typedef struct _net *netptr;
typedef struct _connect *connptr;

typedef struct _net {
   char *name;
   connptr driver;
   short type;
   int fanout;
   connptr *receivers;
   double loadr;	/* Total load capacitance for rising input */
   double loadf;	/* Total load capacitance for falling input */
   netptr next;
} net;

typedef struct _instance *instptr;

typedef struct _connect {
   instptr refinst;
   pinptr refpin;
   netptr refnet;
   connptr next;
} connect;

typedef struct _instance {
   char *name;
   cellptr refcell;
   connptr in_connects;
   connptr out_connects;
   instptr next;
} instance;

/*--------------------------------------------------------------*/
/* Grab a token from the input					*/
/* Return the token, or NULL if we have reached end-of-file.	*/
/*--------------------------------------------------------------*/

char *
advancetoken(FILE *flib, char delimiter)
{
    static char token[LIB_LINE_MAX];
    static char line[LIB_LINE_MAX];
    static char *linepos = NULL;

    char *lineptr = linepos;
    char *lptr, *tptr;
    char *result;
    int commentblock, concat, nest;

    commentblock = 0;
    concat = 0;
    nest = 0;
    while (1) {		/* Keep processing until we get a token or hit EOF */

	if (lineptr != NULL && *lineptr == '/' && *(lineptr + 1) == '*') {
	    commentblock = 1;
	}

	if (commentblock == 1) {
	    if ((lptr = strstr(lineptr, "*/")) != NULL) {
		lineptr = lptr + 2;
		commentblock = 0;
	    }
	    else lineptr = NULL;
	}

	if (lineptr == NULL || *lineptr == '\n' || *lineptr == '\0') {
	    result = fgets(line, LIB_LINE_MAX, flib);
	    fileCurrentLine++;
	    if (result == NULL) return NULL;

	    /* Keep pulling stuff in if the line ends with a continuation character */
 	    lptr = line;
	    while (*lptr != '\n' && *lptr != '\0') {
		if (*lptr == '\\') {
		    result = fgets(lptr, LIB_LINE_MAX - (lptr - line), flib);
		    fileCurrentLine++;
		    if (result == NULL) break;
		}
		else
		    lptr++;
	    }	
	    if (result == NULL) return NULL;
	    lineptr = line;
	}

	if (commentblock == 1) continue;

	while (isspace(*lineptr)) lineptr++;
	if (concat == 0)
	    tptr = token;

	// Find the next token and return just the token.  Update linepos
	// to the position just beyond the token.  All delimiters like
	// parentheses, quotes, etc., are returned as single tokens

	// If delimiter is declared, then we stop when we reach the
	// delimiter character, and return all the text preceding it
	// as the token.  If delimiter is 0, then we look for standard
	// delimiters, and separate them out and return them as tokens
	// if found.

	while (1) {
	    if (*lineptr == '\n' || *lineptr == '\0')
		break;
	    if (*lineptr == '/' && *(lineptr + 1) == '*')
		break;
	    if (delimiter != 0 && *lineptr == delimiter) {
		if (nest > 0)
		    nest--;
		else
		    break;
	    }

	    // Watch for nested delimiters!
	    if (delimiter == '}' && *lineptr == '{') nest++;
	    if (delimiter == ')' && *lineptr == '(') nest++;

	    if (delimiter == 0)
		if (*lineptr == ' ' || *lineptr == '\t')
		    break;

	    if (delimiter == 0) {
		if (*lineptr == '(' || *lineptr == ')') {
		    if (tptr == token) *tptr++ = *lineptr++;
		    break;
		}
		if (*lineptr == '{' || *lineptr == '}') {
		    if (tptr == token) *tptr++ = *lineptr++;
		    break;
		}
		if (*lineptr == '\"' || *lineptr == ':' || *lineptr == ';') {
		    if (tptr == token) *tptr++ = *lineptr++;
		    break;
		}
	    }

	    *tptr++ = *lineptr++;
	}
	*tptr = '\0';
	if ((delimiter != 0) && (*lineptr != delimiter))
	    concat = 1;
	else if ((delimiter != 0) && (*lineptr == delimiter))
	    break;
	else if (tptr > token)
	    break;
    }
    if (delimiter != 0) lineptr++;

    while (isspace(*lineptr)) lineptr++;
    linepos = lineptr;

    // Final:  Remove trailing whitespace
    tptr = token + strlen(token) - 1;
    while (isspace(*tptr)) {
	*tptr = '\0';
	tptr--;
    }
    return token;
}

/*--------------------------------------------------------------*/
/* Expansion of XOR operator "^" into and/or/invert		*/
/*--------------------------------------------------------------*/

char *
xor_expand(char *lib_func)
{
    static char newfunc[16384];
    char savfunc[16384];
    char *xptr, *sptr, *fptr, *rest, *start;
    int nest, lhsnests, rhsnests;
    char *rhs = NULL;
    char *lhs = NULL;

    strcpy(newfunc, lib_func);

    while ((xptr = strchr(newfunc, '^')) != NULL) {

       /* find expression on RHS */
       sptr = xptr + 1;
       while (*sptr == ' ' || *sptr == '\t') sptr++;
       fptr = sptr;
       rhsnests = 0;
       if (*sptr == '(') {
	  rhsnests = 1;
	  nest = 1;
	  while ((*sptr != ')') || (nest > 0)) {
	     sptr++;
	     if (*sptr == '(') nest++;
	     if (*sptr == ')') nest--;
	  }
       }
       else {
	  while (*sptr != ' ' && *sptr != '\t' && *sptr != '\0' &&
			*sptr != ')')
	     sptr++;
	  if (*sptr == ')') sptr--;
       }

       // If argument is a single character, then don't bother with parentheses
       if (sptr - fptr == 0) rhsnests = 1;

       if (rhsnests == 1) {
          rhs = (char *)malloc(sptr - fptr + 2);
          strncpy(rhs, fptr, sptr - fptr + 1);
	  *(rhs + (int)(sptr - fptr + 1)) = '\0';
       }
       else {
	  /* Add parentheses around RHS */
          rhs = (char *)malloc(sptr - fptr + 4);
	  *rhs = '(';
          strncpy(rhs + 1, fptr, sptr - fptr + 1);
	  *(rhs + (int)(sptr - fptr + 2)) = ')';
	  *(rhs + (int)(sptr - fptr + 3)) = '\0';
       }
       rest = sptr + 1;
       
       /* find expression on LHS */
       sptr = xptr - 1;
       while (*sptr == ' ' || *sptr == '\t') sptr--;
       fptr = sptr;
       lhsnests = 0;
       if (*sptr == ')') {
          lhsnests = 1;
	  nest = 1;
	  while ((*sptr != '(') || (nest > 0)) {
	     sptr--;
	     if (*sptr == ')') nest++;
	     if (*sptr == '(') nest--;
	  }
       }
       else {
	  while (*sptr != ' ' && *sptr != '\t' && sptr != lib_func &&
			*sptr != '(')
	     sptr--;
	  if (*sptr == '(') sptr++;
       }

       // If argument is a single character, then don't bother with parentheses
       if (fptr - sptr == 0) lhsnests = 1;

       if (lhsnests == 1) {
          lhs = (char *)malloc(fptr - sptr + 2);
          strncpy(lhs, sptr, fptr - sptr + 1);
	  *(lhs + (int)(fptr - sptr + 1)) = '\0';
       }
       else {
          lhs = (char *)malloc(fptr - sptr + 4);
	  *lhs = '(';
          strncpy(lhs + 1, sptr, fptr - sptr + 1);
	  *(lhs + (int)(fptr - sptr + 2)) = ')';
	  *(lhs + (int)(fptr - sptr + 3)) = '\0';
       }
       strcpy(savfunc, newfunc);
       start = savfunc + (sptr - newfunc);

       sprintf(start, "(%s*!%s + !%s*%s) %s",
		lhs, rhs, lhs, rhs, rest);

	if (rhs != NULL) free(rhs);
	if (lhs != NULL) free(lhs);

	strcpy(newfunc, savfunc);
    }

    return newfunc;
}

/*--------------------------------------------------------------*/
/* Turn a liberty-format function string into one recognized by	*/
/* genlib.  This means, for the most part, replacing forms of	*/
/* "A B" with "A * B", and "A ^ B" with "A * !B + !A * B"	*/
/*--------------------------------------------------------------*/

char *
get_function(char *out_name, char *lib_func)
{
    static char newfunc[16384];
    char *fptr, *sptr;
    int nest;
    int state = INIT;

    fptr = newfunc;
    sptr = out_name;

    while (*sptr != '\0') *fptr++ = *sptr++;
    *fptr++ = ' ';
    *fptr++ = '=';
    *fptr++ = ' ';

    sptr = xor_expand(lib_func); // genlib can't handle "^"

    while (*sptr != '\0') {
	if (*sptr == '(') {
	    if (state == SIGNAL || state == GROUPEND) {
		*fptr++ = '*';	// Implicit AND;  genlib wants to see
		*fptr++ = ' ';	// this written out explicitly.
	    }	   
	    state = GROUPBEGIN;
	    *fptr++ = *sptr++;
	}
	else if (*sptr == ')') {
	    state = GROUPEND;
	    *fptr++ = *sptr++;
	}
	else if (*sptr == '!' || *sptr == '*' || *sptr == '+' || *sptr == '\'') {
	    state = OPERATOR;
	    *fptr++ = *sptr++;
	}
	else if (*sptr == ' ' || *sptr == '\t') {
	    if (state == SIGNAL) {
		state = SEPARATOR;
	    }
	    *fptr++ = *sptr++;
	}
	else if (*sptr == '^') {
	    state = XOPERATOR;
	}
	else {
	    if (state == SEPARATOR || state == GROUPEND) {
		*fptr++ = '*';	// Implicit AND;  genlib wants to see
		*fptr++ = ' ';	// this written out explicitly.
	    }
	    state = SIGNAL;
	    *fptr++ = *sptr++;
	}
    }
    *fptr = '\0';

    // Process single-quote-as-inversion.  That is, A' --> !A
    // The number of characters remains the same, so we can apply
    // the changes directly to newfunc with careful use of memmove

    while ((sptr = strchr(newfunc, '\'')) != NULL) {
	fptr = sptr - 1;
	while (isspace(*fptr)) fptr--;

	if (*fptr == ')') {
	    nest = 1;
	    while (nest > 0) {
		fptr--;
		if (*fptr == ')') nest++;
		else if (*fptr == '(') nest--;
		else if (fptr == newfunc) break;
	    }
	}
	else {
	    while (*fptr != '!' && *fptr != '*' && *fptr != '+' &&
		   !isspace(*fptr) && (fptr > newfunc) && *fptr != '('
		   && *fptr != ')')
		fptr--;
	    if (fptr > newfunc) fptr++;
	}
	memmove(fptr + 1, fptr, (size_t)(sptr - fptr));
	*fptr = '!';
    }

    return newfunc;
}

/*--------------------------------------------------------------*/
/* Name pattern matching.  This is used to restrict the 	*/
/* entries that are placed in genlib.  It understands a few	*/
/* wildcard characters: "^" (matches beginning-of-string), and	*/
/* "$" (matches end-of-string).					*/
/*								*/
/* May want to add "|" and "&" (OR, AND) functions, but maybe	*/
/* it's not necessary.  Also standard wildcards like "." and	*/
/* "*".								*/
/*--------------------------------------------------------------*/

int
pattern_match(char *name, char *pattern)
{
    char *sptr;
    int plen = strlen(pattern);
    int rval = 0;
    int matchend = 0;

    if (*(pattern + plen - 1) == '$') {
	matchend = 1;
	*(pattern + plen - 1) = '\0';
    }

    if (*pattern == '^') {
	sptr = pattern + 1;
	if (matchend) {
	    if (!strcmp(name, sptr))
		rval = 1;
	    else
		rval = 0;
	}
	else {
	    if (!strncmp(name, sptr, plen - 2))
		rval = 1;
	    else
		rval = 0;
	}
    }
    else {
	if (matchend) {
	    sptr = name + strlen(name) - plen + 1;
	    if (!strcmp(sptr, pattern))
		rval = 1;
	    else
		rval = 0;
	}
	else {
	    if (strstr(name, pattern) != NULL)
		rval = 1;
	    else
		rval = 0;
	}
    }

    if (matchend) *(pattern + plen - 1) = '$';
    return rval;
}

/*--------------------------------------------------------------*/
/* Parse a pin name.  Check if the cell has a pin of that name,	*/
/* and if not, add the pin to the cell, giving it default	*/
/* values.  The pin name may contain quotes, parentheses, or	*/
/* negations ("!" or "'");  these should be ignored.		*/
/*--------------------------------------------------------------*/

pinptr parse_pin(cellptr newcell, char *token)
{
    pinptr newpin, lastpin;
    char *pinname, *sptr;

    // Advance to first legal pin name character

    pinname = token;
    while (isspace(*pinname) || (*pinname == '\'') || (*pinname == '\"') ||
		(*pinname == '!') || (*pinname == '(') || (*pinname == ')'))
	pinname++;

    sptr = pinname;
    while (*sptr != '\0') {
	if (isspace(*sptr) || (*sptr == '\'') || (*sptr == '\"') ||
		(*sptr == '!') || (*sptr == '(') || (*sptr == ')')) {
	    *sptr = '\0';
	    break;
	}
	sptr++;
    }

    // Check if pin was already defined

    lastpin = NULL;
    newpin = newcell->pins;
    while (newpin) {
	lastpin = newpin;
	if (!strcmp(newpin->name, pinname))
	    return newpin;
	newpin = newpin->next;
    }

    // Pin was not defined, so create a new one and add it to the cell
    // at the end of the cell's pin list.

    newpin = (pin *)malloc(sizeof(pin));
    newpin->name = strdup(pinname);
    newpin->next = NULL;

    if (lastpin != NULL)
	lastpin->next = newpin;
    else
	newcell->pins = newpin;

    newpin->type = INPUT;	// The default; modified later, if not an input
    newpin->capr = 0.0;
    newpin->capf = 0.0;
    newpin->sense = SENSE_NONE;	// Again, modified later if not true.
    newpin->propdelr = NULL;
    newpin->propdelf = NULL;
    newpin->transr = NULL;
    newpin->transf = NULL;
    newpin->refcell = newcell;	// Create link back to cell
    return newpin;
}

/*--------------------------------------------------------------*/
/* Create a new net record					*/
/*--------------------------------------------------------------*/

netptr create_net(netptr *netlist) {

    netptr newnet;

    newnet = (netptr)malloc(sizeof(net));
    newnet->name = NULL;
    newnet->next = *netlist;
    *netlist = newnet;
    newnet->driver = NULL;
    newnet->fanout = 0;
    newnet->receivers = NULL;
    newnet->loadr = 0.0;
    newnet->loadf = 0.0;
    newnet->type = NET;

    return newnet;
}

/*----------------------------------------------------------------------*/
/* Interpolate or extrapolate a value from a time vs. capacitance	*/
/* lookup table.							*/
/*----------------------------------------------------------------------*/

double binomial_get_value(lutableptr tableptr, double trans, double load)
{
    int i, j;
    double tfrac, cfrac, vlow, vhigh, valuel, valueh, value;

    /* Tables have been arranged such that idx1 is time, idx2 is cap */

    // Find time index entries bounding  "trans", or the two nearest
    // entries, if extrapolating

    if (trans < tableptr->idx1.times[0])
	i = 1;
    else if (trans >= tableptr->idx1.times[tableptr->size1 - 1])
	i = tableptr->size1 - 1;
    else {
	for (i = 0; i < tableptr->size1; i++)
	    if (tableptr->idx1.times[i] > trans)
		break;
    }

    // Compute transition time as a fraction of the nearest table indexes
    // for transition times

    tfrac = (trans - tableptr->idx1.times[i - 1]) /
		(tableptr->idx1.times[i] - tableptr->idx1.times[i - 1]);

    // Find cap load index entries bounding  "load", or the two nearest
    // entries, if extrapolating

    if (load < tableptr->idx2.caps[0])
	j = 1;
    else if (load >= tableptr->idx2.caps[tableptr->size2 - 1])
	j = tableptr->size2 - 1;
    else {
	for (j = 0; j < tableptr->size2; i++)
	    if (tableptr->idx2.caps[i] > load)
		break;
    }

    // Compute load cap as a fraction of the nearest table indexes for load cap

    cfrac = (load - tableptr->idx2.caps[j - 1]) /
			(tableptr->idx2.caps[j] - tableptr->idx2.caps[j - 1]);

    // Interpolate value at cap lower bound
    vlow = *(tableptr->values + (j - 1) * tableptr->size1 + (i - 1));
    vhigh = *(tableptr->values + (j - 1) * tableptr->size1 + i);
    valuel = vlow + (vhigh - vlow) * tfrac;

    // Interpolate value at cap upper bound
    vlow = *(tableptr->values + j * tableptr->size1 + (i - 1));
    vhigh = *(tableptr->values + j * tableptr->size1 + i);
    valueh = vlow + (vhigh - vlow) * tfrac;

    // Final interpolation (binomial interpolation)
    value = valuel + (valueh - valuel) * cfrac;
    return value;
}

/*----------------------------------------------------------------------*/
/* Calculate the propagation delay from "testpin" to the output		*/
/* of the gate to which "testpin" is an input.				*/
/*									*/
/* "sense" is a pointer to the sense at the input.  SENSE_POSITIVE	*/
/* indicates a rising edge at the pin, SENSE_NEGATIVE indicates a	*/
/* falling edge at the pin.  "sense" is updated to indicate if the	*/
/* output transition is rising, falling, or unknown (SENSE_NONE).	*/
/*									*/
/* "loadnet" is a pointer to the net connected to the cell instance's	*/
/* output pin.  Load values will be taken from this net, depending on	*/
/* the sense of the output.						*/
/*									*/
/* "testpin" is the pin receiving the input signal, and the pin	record	*/
/* containing the relevant timing tables.				*/
/*----------------------------------------------------------------------*/

double calc_prop_delay(double trans, netptr loadnet, pinptr testpin, short *sense)
{
    double propdelayr, propdelayf;
    short outsense;

    outsense = testpin->sense;
    switch(*sense) {
	case SENSE_POSITIVE:
	    if (testpin->sense == SENSE_POSITIVE)
		outsense = SENSE_POSITIVE;	/* rising input, rising output */
	    else if (testpin->sense = SENSE_NEGATIVE)
		outsense = SENSE_NEGATIVE;	/* rising input, falling output */
	    else
		outsense = SENSE_NONE;		/* output can be rising or falling */
	    break;
	case SENSE_NEGATIVE:
	    if (testpin->sense == SENSE_POSITIVE)
		outsense = SENSE_NEGATIVE;	/* falling input, falling output */
	    else if (testpin->sense = SENSE_NEGATIVE)
		outsense = SENSE_POSITIVE;	/* falling input, rising output */
	    else
		outsense = SENSE_NONE;		/* output can be rising or falling */
	    break;
	case SENSE_NONE:
	    outsense = SENSE_NONE;		/* output can be rising or falling */
	    break;
    }

    propdelayr = 0.0;
    propdelayf = 0.0;

    if (outsense != SENSE_NEGATIVE)
	propdelayr = binomial_get_value(testpin->propdelr, trans, loadnet->loadr);

    if (outsense != SENSE_POSITIVE)
	propdelayf = binomial_get_value(testpin->propdelf, trans, loadnet->loadf);

    return (propdelayr > propdelayf) ? propdelayr : propdelayf;
}

/*----------------------------------------------------------------------*/
/* Calculate the transition time from "testpin" to the output		*/
/* of the gate to which "testpin" is an input.	This is equivalent to	*/
/* the propagation delay calculation routine above, apart from using	*/
/* the lookup tables for transition time instead of propagation delay.	*/
/*----------------------------------------------------------------------*/

double calc_transition(double trans, netptr loadnet, pinptr testpin, short *sense)
{
    double transr, transf;
    short outsense;

    outsense = testpin->sense;
    switch(*sense) {
	case SENSE_POSITIVE:
	    if (testpin->sense == SENSE_POSITIVE)
		outsense = SENSE_POSITIVE;	/* rising input, rising output */
	    else if (testpin->sense = SENSE_NEGATIVE)
		outsense = SENSE_NEGATIVE;	/* rising input, falling output */
	    else
		outsense = SENSE_NONE;		/* output can be rising or falling */
	    break;
	case SENSE_NEGATIVE:
	    if (testpin->sense == SENSE_POSITIVE)
		outsense = SENSE_NEGATIVE;	/* falling input, falling output */
	    else if (testpin->sense = SENSE_NEGATIVE)
		outsense = SENSE_POSITIVE;	/* falling input, rising output */
	    else
		outsense = SENSE_NONE;		/* output can be rising or falling */
	    break;
	case SENSE_NONE:
	    outsense = SENSE_NONE;		/* output can be rising or falling */
	    break;
    }

    transr = 0.0;
    transf = 0.0;

    if (outsense != SENSE_NEGATIVE)
	transr = binomial_get_value(testpin->transr, trans, loadnet->loadr);

    if (outsense != SENSE_POSITIVE)
	transf = binomial_get_value(testpin->transf, trans, loadnet->loadf);

    return (transr > transf) ? transr : transf;
}

/*--------------------------------------------------------------*/
/*--------------------------------------------------------------*/

void find_clock_to_term_paths(connptr clockedlist)
{
    connptr testlink;
    pinptr testpin;
    netptr testnet, loadnet;
    cellptr testcell;
    instptr testinst;

    short  sense;
    double delay = 0.0;
    double trans = 0.0;		// Rising or falling, depending on sense

    for (testlink = clockedlist; testlink; testlink = testlink->next) {
	testnet = testlink->refnet;
	testpin = testlink->refpin;
	testinst = testlink->refinst;
	testcell = testpin->refcell;

	// Sense is positive for rising edge-triggered flops, negative for
	// falling edge-triggered flops

	if (testcell->type & CLK_SENSE_MASK)
	    sense = SENSE_NEGATIVE;
	else
	    sense = SENSE_POSITIVE;

	// Assuming a driving transition time of 0, compute delay
	// from clock edge to output

	loadnet = testinst->out_connects->refnet;
	delay = calc_prop_delay(trans, loadnet, testpin, &sense);
	trans = calc_transition(trans, loadnet, testpin, &sense);
    }
}

/*--------------------------------------------------------------*/
/* Parse a table variable type from a liberty format file	*/
/*--------------------------------------------------------------*/

int get_table_type(char *token) {
    if (!strcasecmp(token, "input_net_transition"))
	return TRANSITION_TIME;
    else if (!strcasecmp(token, "total_output_net_capacitance"))
	return OUTPUT_CAP;
    else if (!strcasecmp(token, "related_pin_transition"))
	return RELATED_TIME;
    else if (!strcasecmp(token, "constrained_pin_transition"))
	return CONSTRAINED_TIME;
    else
	return UNKNOWN;
}

/*--------------------------------------------------------------*/
/* Read a liberty format file and collect information about	*/
/* the timing properties of each standard cell.			*/
/*--------------------------------------------------------------*/

void
libertyRead(FILE *flib, lutable **tablelist, cell **celllist)
{
    char *token;
    char *libname = NULL;
    int section = INIT;

    double time_unit = 1.0;	// Time unit multiplier, to get ps
    double cap_unit = 1.0;	// Capacitive unit multiplier, to get fF

    pinptr testpin;
    lutable *tableptr;

    int i, j;
    double gval;
    char *iptr;

    lutable *newtable, *reftable;
    cell *newcell, *lastcell;
    pin *newpin;

    lastcell = NULL;

    /* Read tokens off of the line */
    token = advancetoken(flib, 0);

    while (token != NULL) {

	switch (section) {
	    case INIT:
		if (!strcasecmp(token, "library")) {
		    token = advancetoken(flib, 0);
		    if (strcmp(token, "("))
			fprintf(stderr, "Library not followed by name\n");
		    else
			token = advancetoken(flib, ')');
		    fprintf(stderr, "Parsing library \"%s\"\n", token);
		    libname = strdup(token);
		    token = advancetoken(flib, 0);
		    if (strcmp(token, "{")) {
			fprintf(stderr, "Did not find opening brace "
					"on library block\n");
			exit(1);
		    }
		    section = LIBBLOCK;
		}
		else
		    fprintf(stderr, "Unknown input \"%s\", looking for "
					"\"library\"\n", token);
		break;

	    case LIBBLOCK:
		// Here we check for the main blocks, again not rigorously. . .

		if (!strcasecmp(token, "}")) {
		    fprintf(stdout, "End of library at line %d\n", fileCurrentLine);
		    section = INIT;			// End of library block
		}
		else if (!strcasecmp(token, "delay_model")) {
		    token = advancetoken(flib, 0);
		    if (strcmp(token, ":"))
			fprintf(stderr, "Input missing colon\n");
		    token = advancetoken(flib, ';');
		    if (strcasecmp(token, "table_lookup")) {
			fprintf(stderr, "Sorry, only know how to "
					"handle table lookup!\n");
			exit(1);
		    }
		}
		else if (!strcasecmp(token, "lu_table_template")) {
		    // Read in template information;
		    newtable = (lutable *)malloc(sizeof(lutable));
		    newtable->var1 = UNKNOWN;
		    newtable->var2 = UNKNOWN;
		    newtable->size1 = 0;
		    newtable->size2 = 0;
		    newtable->idx1.times = NULL;
		    newtable->idx2.caps = NULL;
		    newtable->next = *tablelist;
		    *tablelist = newtable;

		    token = advancetoken(flib, 0);
		    if (strcmp(token, "("))
			fprintf(stderr, "Input missing open parens\n");
		    else
			token = advancetoken(flib, ')');
		    newtable->name = strdup(token);
		    while (*token != '}') {
			token = advancetoken(flib, 0);
			if (!strcasecmp(token, "variable_1")) {
			    token = advancetoken(flib, 0);
			    token = advancetoken(flib, ';');
			    newtable->var1 = get_table_type(token);
			    if (newtable->var1 == OUTPUT_CAP || newtable->var1 == CONSTRAINED_TIME)
				newtable->invert = 1;
			}
			else if (!strcasecmp(token, "variable_2")) {
			    token = advancetoken(flib, 0);
			    token = advancetoken(flib, ';');
			    newtable->var2 = get_table_type(token);
			    if (newtable->var1 == TRANSITION_TIME || newtable->var1 == RELATED_TIME)
				newtable->invert = 1;
			}
			else if (!strcasecmp(token, "index_1")) {
			    token = advancetoken(flib, 0);	// Open parens
			    token = advancetoken(flib, 0);	// Quote
			    if (!strcmp(token, "\""))
				token = advancetoken(flib, '\"');

			    if (newtable->invert == 1) {
				// Count entries
				iptr = token;
				newtable->size2 = 1;
				while ((iptr = strchr(iptr, ',')) != NULL) {
				    iptr++;
				    newtable->size2++;
				}
				newtable->idx2.caps = (double *)malloc(newtable->size2 *
					sizeof(double));
				newtable->size2 = 0;
				iptr = token;
				sscanf(iptr, "%lg", &newtable->idx2.caps[0]);
				if (newtable->var2 == OUTPUT_CAP)
				    newtable->idx2.caps[0] *= cap_unit;
				else
				    newtable->idx2.caps[0] *= time_unit;

				while ((iptr = strchr(iptr, ',')) != NULL) {
				    iptr++;
				    newtable->size2++;
				    sscanf(iptr, "%lg",
						&newtable->idx2.caps[newtable->size2]);
				    if (newtable->var2 == OUTPUT_CAP)
					newtable->idx2.caps[newtable->size2] *= cap_unit;
				    else
					newtable->idx2.cons[newtable->size2] *= time_unit;
				}
				newtable->size2++;
			    }
			    else {	// newtable->invert = 0
				// Count entries
				iptr = token;
				newtable->size1 = 1;
				while ((iptr = strchr(iptr, ',')) != NULL) {
				    iptr++;
				    newtable->size1++;
				}
				newtable->idx1.times = (double *)malloc(newtable->size1 *
					sizeof(double));
				newtable->size1 = 0;
				iptr = token;
				sscanf(iptr, "%lg", &newtable->idx1.times[0]);
				newtable->idx1.times[0] *= time_unit; 
				while ((iptr = strchr(iptr, ',')) != NULL) {
				    iptr++;
				    newtable->size1++;
				    sscanf(iptr, "%lg",
						&newtable->idx1.times[newtable->size1]);
				    newtable->idx1.times[newtable->size1] *= time_unit;
				}
				newtable->size1++;
			    }

			    token = advancetoken(flib, ';'); // EOL semicolon
			}
			else if (!strcasecmp(token, "index_2")) {
			    token = advancetoken(flib, 0);	// Open parens
			    token = advancetoken(flib, 0);	// Quote
			    if (!strcmp(token, "\""))
				token = advancetoken(flib, '\"');

			    if (newtable->invert == 0) {
				// Count entries
				iptr = token;
				newtable->size2 = 1;
				while ((iptr = strchr(iptr, ',')) != NULL) {
				    iptr++;
				    newtable->size2++;
				}
				newtable->idx2.caps = (double *)malloc(newtable->size2 *
					sizeof(double));
				newtable->size2 = 0;
				iptr = token;
				sscanf(iptr, "%lg", &newtable->idx2.caps[0]);
				if (newtable->var2 == OUTPUT_CAP)
				    newtable->idx2.caps[0] *= cap_unit;
				else
				    newtable->idx2.cons[0] *= time_unit;
				while ((iptr = strchr(iptr, ',')) != NULL) {
				    iptr++;
				    newtable->size2++;
				    sscanf(iptr, "%lg",
						&newtable->idx2.caps[newtable->size2]);
				    if (newtable->var2 == OUTPUT_CAP)
					newtable->idx2.caps[newtable->size2] *= cap_unit;
				    else
					newtable->idx2.cons[newtable->size2] *= time_unit;
				}
				newtable->size2++;
			    }
			    else { 	// newtable->invert == 1
				// Count entries
				iptr = token;
				newtable->size1 = 1;
				while ((iptr = strchr(iptr, ',')) != NULL) {
				    iptr++;
				    newtable->size1++;
				}
				newtable->idx1.times = (double *)malloc(newtable->size1 *
					sizeof(double));
				newtable->size1 = 0;
				iptr = token;
				sscanf(iptr, "%lg", &newtable->idx1.times[0]);
				newtable->idx1.times[0] *= time_unit;
				while ((iptr = strchr(iptr, ',')) != NULL) {
				    iptr++;
				    newtable->size1++;
				    sscanf(iptr, "%lg",
						&newtable->idx1.times[newtable->size1]);
				    newtable->idx1.times[newtable->size1] *= time_unit;
				}
				newtable->size1++;
			    }

			    token = advancetoken(flib, ';'); // EOL semicolon
			}
		    }
		}
		else if (!strcasecmp(token, "cell")) {
		    newcell = (cell *)malloc(sizeof(cell));
		    newcell->next = NULL;
		    if (lastcell != NULL)
			lastcell->next = newcell;
		    else
			*celllist = newcell;
		    lastcell = newcell;
		    token = advancetoken(flib, 0);	// Open parens
		    if (!strcmp(token, "("))
			token = advancetoken(flib, ')');	// Cellname
		    newcell->name = strdup(token);
		    token = advancetoken(flib, 0);	// Find start of block
		    if (strcmp(token, "{"))
			fprintf(stderr, "Error: failed to find start of block\n");
		    newcell->type = GATE;		// Default type
		    newcell->function = NULL;
		    newcell->pins = NULL;
		    newcell->area = 1.0;
		    newcell->maxtrans = 0.0;
		    newcell->maxcap = 0.0;
		    section = CELLDEF;
		}
		else if (!strcasecmp(token, "time_unit")) {
		   char *metric;

		   token = advancetoken(flib, 0);
		   if (token == NULL) break;
		   if (!strcmp(token, ":")) {
		      token = advancetoken(flib, 0);
		      if (token == NULL) break;
		   }
		   if (!strcmp(token, "\"")) {
		      token = advancetoken(flib, '\"');
		      if (token == NULL) break;
		   }
		   time_unit = strtod(token, &metric);
		   if (*metric != '\0') {
		      if (!strcmp(metric, "ns"))
			 time_unit *= 1E3;
		      else if (!strcmp(metric, "us"))
			 time_unit *= 1E6;
		      else if (!strcmp(metric, "fs"))
			 time_unit *= 1E-3;
		      else if (strcmp(metric, "ps"))
			 fprintf(stderr, "Don't understand time units \"%s\"\n",
				token);
		   }
		   else {
		      token = advancetoken(flib, 0);
		      if (token == NULL) break;
		      if (!strcmp(token, "ns"))
			 time_unit *= 1E3;
		      else if (!strcmp(token, "us"))
			 time_unit *= 1E6;
		      else if (!strcmp(token, "fs"))
			 time_unit *= 1E-3;
		      else if (strcmp(token, "ps"))
			 fprintf(stderr, "Don't understand time units \"%s\"\n",
				token);
		   }
		   token = advancetoken(flib, ';');
		}
		else if (!strcasecmp(token, "capacitive_load_unit")) {
		   char *metric;

		   token = advancetoken(flib, 0);
		   if (token == NULL) break;
		   if (!strcmp(token, "(")) {
		      token = advancetoken(flib, ')');
		      if (token == NULL) break;
		   }
		   cap_unit = strtod(token, &metric);
		   if (*metric != '\0') {
		      while (isspace(*metric)) metric++;
		      if (*metric == ',') metric++;
		      while ((*metric != '\0') && isspace(*metric)) metric++;
		      if (!strcasecmp(metric, "af"))
			 cap_unit *= 1E-3;
		      else if (!strcasecmp(metric, "pf"))
			 cap_unit *= 1000;
		      else if (!strcasecmp(metric, "nf"))
			 cap_unit *= 1E6;
		      else if (!strcasecmp(metric, "uf"))
			 cap_unit *= 1E9;
		      else if (strcasecmp(metric, "ff"))
			 fprintf(stderr, "Don't understand capacitive units \"%s\"\n",
				token);
		   }
		   else {
		      token = advancetoken(flib, 0);
		      if (token == NULL) break;
		      if (!strcasecmp(token, "af"))
			 cap_unit *= 1E-3;
		      else if (!strcasecmp(token, "pf"))
			 cap_unit *= 1000;
		      else if (!strcasecmp(token, "nf"))
			 cap_unit *= 1E6;
		      else if (!strcasecmp(token, "uf"))
			 cap_unit *= 1E9;
		      else if (strcasecmp(token, "ff"))
			 fprintf(stderr, "Don't understand capacitive units \"%s\"\n",
				token);
		   }
		   token = advancetoken(flib, ';');
		}
		else {
		    // For unhandled tokens, read in tokens.  If it is
		    // a definition or function, read to end-of-line.  If
		    // it is a block definition, read to end-of-block.
		    while (1) {
			token = advancetoken(flib, 0);
			if (token == NULL) break;
			if (!strcmp(token, ";")) break;
			if (!strcmp(token, "\""))
			    token = advancetoken(flib, '\"');
			if (!strcmp(token, "{")) {
			    token = advancetoken(flib, '}');
			    break;
			}
		    }
		}
		break;

	    case CELLDEF:

		if (!strcmp(token, "}")) {
		    section = LIBBLOCK;			// End of cell def
		}
		else if (!strcasecmp(token, "pin")) {
		    token = advancetoken(flib, 0);	// Open parens
		    if (!strcmp(token, "("))
			token = advancetoken(flib, ')');	// Close parens

		    newpin = parse_pin(newcell, token);

		    token = advancetoken(flib, 0);	// Find start of block
		    if (strcmp(token, "{"))
			fprintf(stderr, "Error: failed to find start of block\n");
		    section = PINDEF;
		}		
		else if (!strcasecmp(token, "area")) {
		    token = advancetoken(flib, 0);	// Colon
		    token = advancetoken(flib, ';');	// To end-of-statement
		    sscanf(token, "%lg", &newcell->area);
		}
		else if (!strcasecmp(token, "ff")) {
		    newcell->type |= DFF;
		    token = advancetoken(flib, '{');
		    section = FLOPDEF;
		}
		else if (!strcasecmp(token, "latch")) {
		    newcell->type |= LATCH;
		    token = advancetoken(flib, '{');
		    section = LATCHDEF;
		}
		else {
		    // For unhandled tokens, read in tokens.  If it is
		    // a definition or function, read to end-of-line.  If
		    // it is a block definition, read to end-of-block.
		    while (1) {
			token = advancetoken(flib, 0);
			if (token == NULL) break;
			if (!strcmp(token, ";")) break;
			if (!strcmp(token, "\""))
			    token = advancetoken(flib, '\"');
			if (!strcmp(token, "("))
			    token = advancetoken(flib, ')');
			if (!strcmp(token, "{")) {
			    token = advancetoken(flib, '}');
			    break;
			}
		    }
		}
		break;

	    case FLOPDEF:

		if (!strcmp(token, "}")) {
		    section = CELLDEF;			// End of flop def
		}
		else if (!strcasecmp(token, "next_state")) {
		    token = advancetoken(flib, 0);	// Colon
		    token = advancetoken(flib, ';');	// To end-of-statement
		    newpin = parse_pin(newcell, token);
		    newpin->type |= DFFIN;
		}
		else if (!strcasecmp(token, "clocked_on")) {
		    token = advancetoken(flib, 0);	// Colon
		    token = advancetoken(flib, ';');	// To end-of-statement
		    if (strchr(token, '\'') != NULL)
			newcell->type |= CLK_SENSE_MASK;
		    else if (strchr(token, '!') != NULL)
			newcell->type |= CLK_SENSE_MASK;
		    newpin = parse_pin(newcell, token);
		    newpin->type |= DFFCLK;
		}
		else if (!strcasecmp(token, "clear")) {
		    newcell->type |= RST_MASK;
		    token = advancetoken(flib, 0);	// Colon
		    token = advancetoken(flib, ';');	// To end-of-statement
		    if (strchr(token, '\'') != NULL)
			newcell->type |= RST_SENSE_MASK;
		    else if (strchr(token, '!') != NULL)
			newcell->type |= RST_SENSE_MASK;
		    newpin = parse_pin(newcell, token);
		    newpin->type |= DFFRST;
		}
		else if (!strcasecmp(token, "preset")) {
		    newcell->type |= SET_MASK;
		    token = advancetoken(flib, 0);	// Colon
		    token = advancetoken(flib, ';');	// To end-of-statement
		    if (strchr(token, '\'') != NULL)
			newcell->type |= SET_SENSE_MASK;
		    else if (strchr(token, '!') != NULL)
			newcell->type |= SET_SENSE_MASK;
		    newpin = parse_pin(newcell, token);
		    newpin->type |= DFFSET;
		}
		else
		    token = advancetoken(flib, ';');	// Read to end-of-statement

		break;

	    case LATCHDEF:

		if (!strcmp(token, "}")) {
		    section = CELLDEF;			// End of flop def
		}
		else if (!strcasecmp(token, "data_in")) {
		    token = advancetoken(flib, 0);	// Colon
		    token = advancetoken(flib, ';');	// To end-of-statement
		    newpin = parse_pin(newcell, token);
		    newpin->type |= LATCHIN;
		}
		else if (!strcasecmp(token, "enable")) {
		    token = advancetoken(flib, 0);	// Colon
		    token = advancetoken(flib, ';');	// To end-of-statement
		    if (strchr(token, '\'') != NULL)
			newcell->type |= EN_SENSE_MASK;
		    else if (strchr(token, '!') != NULL)
			newcell->type |= EN_SENSE_MASK;
		    newpin = parse_pin(newcell, token);
		    newpin->type |= LATCHEN;
		}
		else
		    token = advancetoken(flib, ';');	// Read to end-of-statement

		break;

	    case PINDEF:

		if (!strcmp(token, "}")) {
		    section = CELLDEF;			// End of pin def
		}
		else if (!strcasecmp(token, "capacitance")) {
		    token = advancetoken(flib, 0);	// Colon
		    token = advancetoken(flib, ';');	// To end-of-statement
		    sscanf(token, "%lg", &newpin->capr);
		    newpin->capr *= cap_unit;
		}
		else if (!strcasecmp(token, "rise_capacitance")) {
		    token = advancetoken(flib, 0);	// Colon
		    token = advancetoken(flib, ';');	// To end-of-statement
		    sscanf(token, "%lg", &newpin->capr);
		    newpin->capr *= cap_unit;
		}
		else if (!strcasecmp(token, "fall_capacitance")) {
		    token = advancetoken(flib, 0);	// Colon
		    token = advancetoken(flib, ';');	// To end-of-statement
		    sscanf(token, "%lg", &newpin->capf);
		    newpin->capf *= cap_unit;
		}
		else if (!strcasecmp(token, "function")) {
		    token = advancetoken(flib, 0);	// Colon
		    token = advancetoken(flib, 0);	// Open quote
		    if (!strcmp(token, "\""))
			token = advancetoken(flib, '\"');	// Find function string
		    if (newpin->type & OUTPUT) {
			char *rfunc = get_function(newpin->name, token);
			newcell->function = strdup(rfunc);
		    }
		    token = advancetoken(flib, 0);
		    if (strcmp(token, ";"))
			fprintf(stderr, "Expected end-of-statement.\n");
		}
		else if (!strcasecmp(token, "direction")) {
		    token = advancetoken(flib, 0);	// Colon
		    token = advancetoken(flib, ';');
		    if (!strcasecmp(token, "input")) {
			newpin->type |= INPUT;
		    }
		    else if (!strcasecmp(token, "output")) {
			newpin->type |= OUTPUT;
		    }
		}
		else if (!strcasecmp(token, "max_transition")) {
		    token = advancetoken(flib, 0);	// Colon
		    token = advancetoken(flib, ';');	// To end-of-statement
		    sscanf(token, "%lg", &newcell->maxtrans);
		    newcell->maxtrans *= time_unit;
		}
		else if (!strcasecmp(token, "max_capacitance")) {
		    token = advancetoken(flib, 0);	// Colon
		    token = advancetoken(flib, ';');	// To end-of-statement
		    sscanf(token, "%lg", &newcell->maxcap);
		    newcell->maxcap *= cap_unit;
		}
		else if (!strcasecmp(token, "timing")) {
		    token = advancetoken(flib, 0);	// Arguments, if any
		    if (strcmp(token, "("))
			fprintf(stderr, "Error: failed to find start of block\n");
		    else
		       token = advancetoken(flib, ')');	// Arguments, if any
		    token = advancetoken(flib, 0);	// Find start of block
		    if (strcmp(token, "{"))
			fprintf(stderr, "Error: failed to find start of block\n");
		    section = TIMING;
		}
		else {
		    // For unhandled tokens, read in tokens.  If it is
		    // a definition or function, read to end-of-line.  If
		    // it is a block definition, read to end-of-block.
		    while (1) {
			token = advancetoken(flib, 0);
			if (token == NULL) break;
			if (!strcmp(token, ";")) break;
			if (!strcmp(token, "\""))
			    token = advancetoken(flib, '\"');
			if (!strcmp(token, "{")) {
			    token = advancetoken(flib, '}');
			    break;
			}
		    }
		}
		break;

	    case TIMING:

		if (!strcmp(token, "}")) {
		    section = PINDEF;			// End of timing def
		}
		else if (!strcasecmp(token, "related_pin")) {
		    token = advancetoken(flib, 0);	// Colon
		    token = advancetoken(flib, ';');	// Read to end of statement
		    // Create the related pin if needed
		    testpin = parse_pin(newcell, token);
		}
		else if (!strcasecmp(token, "timing_sense")) {
		    token = advancetoken(flib, 0);	// Colon
		    if (!strcasecmp(token, "positive_unate"))
			testpin->sense = SENSE_POSITIVE;
		    else if (!strcasecmp(token, "negative_unate"))
			testpin->sense = SENSE_NEGATIVE;
		    else if (!strcasecmp(token, "non_unate"))
			testpin->sense = SENSE_NONE;
		}
		else if (!strcasecmp(token, "timing_type")) {
		    token = advancetoken(flib, 0);	// Colon

		    // Note:  Timing type is apparently redundant information;
		    // e.g., "falling_edge" can be determined by "clocked_on : !CLK"
		    // in the ff {} block.  How reliable is this?

		    /*-----------------------------------------
		    if (!strcasecmp(token, "rising_edge"))
		    else if (!strcasecmp(token, "falling_edge"))
		    else if (!strcasecmp(token, "hold_rising"))
		    else if (!strcasecmp(token, "hold_falling"))
		    else if (!strcasecmp(token, "setup_rising"))
		    else if (!strcasecmp(token, "setup_falling"))
		    else if (!strcasecmp(token, "clear"))
		    else if (!strcasecmp(token, "preset"))
		    else if (!strcasecmp(token, "recovery_rising"))
		    else if (!strcasecmp(token, "recovery_falling"))
		    else if (!strcasecmp(token, "removal_rising"))
		    else if (!strcasecmp(token, "removal_falling"))
		    else if (!strcasecmp(token, "three_state_enable"))
		    else if (!strcasecmp(token, "three_state_disable"))
		    -----------------------------------------*/

		    token = advancetoken(flib, ';');	// Read to end of statement
		
		}
		else if ((!strcasecmp(token, "cell_rise")) ||
			(!strcasecmp(token, "cell_fall")) ||
			(!strcasecmp(token, "rise_transition")) ||
			(!strcasecmp(token, "fall_transition")) ||
			(!strcasecmp(token, "rise_constraint")) ||
			(!strcasecmp(token, "fall_constraint"))) {

		    tableptr = (lutable *)malloc(sizeof(lutable));
		    tableptr->name = NULL;	// Not used
		    tableptr->invert = 0;
		    tableptr->var1 = UNKNOWN;
		    tableptr->var2 = UNKNOWN;
		    tableptr->size1 = 0;
		    tableptr->size2 = 0;
		    tableptr->idx1.times = NULL;
		    tableptr->idx2.caps = NULL;
		    tableptr->values = NULL;
		    tableptr->next = NULL;	// Not used

		    // Note that propagation delays (cell rise, cell fall) and
		    // transition times (rise transition, fall transition) have
		    // their lookup tables stored in the "related pin" pin record.
		    // Setup and hold times (rise constraint, fall constraint)
		    // have their lookup tables stored in the original pin record.
		    // These should not overlap.

		    // Recovery and removal tables are not yet handled. . .

		    if (!strcasecmp(token, "cell_rise"))
			testpin->propdelr = tableptr;
		    else if (!strcasecmp(token, "cell_fall"))
			testpin->propdelf = tableptr;
		    else if (!strcasecmp(token, "rise_transition"))
			testpin->transr = tableptr;
		    else if (!strcasecmp(token, "fall_transition"))
			testpin->transf = tableptr;
		    else if (!strcasecmp(token, "rise_constraint"))
			newpin->propdelr = tableptr;
		    else if (!strcasecmp(token, "fall_constraint"))
			newpin->propdelr = tableptr;

		    token = advancetoken(flib, 0);	// Open parens
		    if (!strcmp(token, "("))
			token = advancetoken(flib, ')');
		    if (strcmp(token, "scalar")) {
			
		        for (reftable = *tablelist; reftable; reftable = reftable->next)
			    if (!strcmp(reftable->name, token))
			        break;
		        if (reftable == NULL)
			    fprintf(stderr, "Failed to find a valid table \"%s\"\n",
				    token);
		        else {
			    // Fill in default values from template reftable
			    tableptr->invert = reftable->invert;
			    if (reftable->size1 > 0) {
				tableptr->var1 = reftable->var1;
				tableptr->size1 = reftable->size1;
				tableptr->idx1.times = (double *)malloc(tableptr->size1 * sizeof(double));
				memcpy(tableptr->idx1.times, reftable->idx1.times,
						tableptr->size1 * sizeof(double));
			    }
			    if (reftable->size2 > 0) {
				tableptr->var2 = reftable->var2;
				tableptr->size2 = reftable->size2;
				tableptr->idx2.caps = (double *)malloc(tableptr->size2 * sizeof(double));
				memcpy(tableptr->idx2.caps, reftable->idx2.caps,
						tableptr->size2 * sizeof(double));
			    }
			}
		    }

		    token = advancetoken(flib, 0);
		    if (strcmp(token, "{"))
			fprintf(stderr, "Failed to find start of timing block\n");

		    while (*token != '}') {
		        token = advancetoken(flib, 0);
		        if (!strcasecmp(token, "index_1")) {

			    // Local index values override those in the template

			    token = advancetoken(flib, 0);	// Open parens
			    token = advancetoken(flib, 0);	// Quote
			    if (!strcmp(token, "\""))
				token = advancetoken(flib, '\"');

			    //-------------------------

			    if (reftable && (reftable->invert == 1)) {
				// Entries had better match the ref table
				iptr = token;
				i = 0;
				sscanf(iptr, "%lg", &tableptr->idx2.caps[0]);
				if (tableptr->var2 == OUTPUT_CAP)
				    tableptr->idx2.caps[0] *= cap_unit;
				else
				    tableptr->idx2.cons[0] *= time_unit;
				while ((iptr = strchr(iptr, ',')) != NULL) {
				    iptr++;
				    i++;
				    sscanf(iptr, "%lg", &tableptr->idx2.caps[i]);
				    if (tableptr->var2 == OUTPUT_CAP)
					tableptr->idx2.caps[i] *= cap_unit;
				    else
					tableptr->idx2.cons[i] *= time_unit;
				}
			    }
			    else if (reftable && (reftable->invert == 0)) {
				iptr = token;
				i = 0;
				sscanf(iptr, "%lg", &tableptr->idx1.times[0]);
				tableptr->idx1.times[0] *= time_unit;
				while ((iptr = strchr(iptr, ',')) != NULL) {
				    iptr++;
				    i++;
				    sscanf(iptr, "%lg", &tableptr->idx1.times[i]);
				    tableptr->idx1.times[i] *= time_unit;
				}
			    }

			    token = advancetoken(flib, ')'); 	// Close paren
			    token = advancetoken(flib, ';');	// EOL semicolon
			}
		        else if (!strcasecmp(token, "index_2")) {

			    // Local index values override those in the template

			    token = advancetoken(flib, 0);	// Open parens
			    token = advancetoken(flib, 0);	// Quote
			    if (!strcmp(token, "\""))
				token = advancetoken(flib, '\"');

			    //-------------------------

			    if (reftable && (reftable->invert == 1)) {
				// Entries had better match the ref table
				iptr = token;
				i = 0;
				sscanf(iptr, "%lg", &tableptr->idx1.times[0]);
				tableptr->idx1.times[0] *= time_unit;
				while ((iptr = strchr(iptr, ',')) != NULL) {
				    iptr++;
				    i++;
				    sscanf(iptr, "%lg", &tableptr->idx1.times[i]);
				    tableptr->idx1.times[i] *= time_unit;
				}
			    }
			    else if (reftable && (reftable->invert == 0)) {
				iptr = token;
				i = 0;
				sscanf(iptr, "%lg", &tableptr->idx2.caps[0]);
				tableptr->idx2.caps[0] *= cap_unit;
				while ((iptr = strchr(iptr, ',')) != NULL) {
				    iptr++;
				    i++;
				    sscanf(iptr, "%lg", &tableptr->idx2.caps[i]);
				    tableptr->idx2.caps[i] *= cap_unit;
				}
			    }

			    token = advancetoken(flib, ')'); 	// Close paren
			    token = advancetoken(flib, ';');	// EOL semicolon
			}
			else if (!strcasecmp(token, "values")) {
			    token = advancetoken(flib, 0);	
			    if (strcmp(token, "("))
				fprintf(stderr, "Failed to find start of"
						" value table\n");
			    token = advancetoken(flib, ')');

			    // Parse the string of values and enter it into the
			    // table "values", which is size size2 x size1

			    if (reftable && reftable->size2 > 0 && reftable->size1 > 0) {
				if (reftable->invert) {
				    tableptr->values = (double *)malloc(reftable->size2 *
						reftable->size1 * sizeof(double));
				    iptr = token;
				    for (i = 0; i < reftable->size1; i++) {
					for (j = 0; j < reftable->size2; j++) {
					    while (*iptr == ' ' || *iptr == '\"' ||
							*iptr == ',')
						iptr++;
					    sscanf(iptr, "%lg", &gval);
					    *(tableptr->values + j * reftable->size1
							+ i) = gval * time_unit;
					    while (*iptr != ' ' && *iptr != '\"' &&
							*iptr != ',')
						iptr++;
					}
				    }
				}
				else {
				    tableptr->values = (double *)malloc(reftable->size2 *
						reftable->size1 * sizeof(double));
				    iptr = token;
				    for (j = 0; j < reftable->size2; j++) {
					for (i = 0; i < reftable->size1; i++) {
					    while (*iptr == ' ' || *iptr == '\"' ||
							*iptr == ',')
						iptr++;
					    sscanf(iptr, "%lg", &gval);
					    *(tableptr->values + j * reftable->size1
							+ i) = gval * time_unit;
					    while (*iptr != ' ' && *iptr != '\"' &&
							*iptr != ',')
						iptr++;
					}
				    }
				}
			    }

			    token = advancetoken(flib, 0);
			    if (strcmp(token, ";"))
				fprintf(stderr, "Failed to find end of value table\n");
			    token = advancetoken(flib, 0);

			}
			else if (strcmp(token, "{"))
			    fprintf(stderr, "Failed to find end of timing block\n");
		    }
		}
		else {
		    // For unhandled tokens, read in tokens.  If it is
		    // a definition or function, read to end-of-line.  If
		    // it is a block definition, read to end-of-block.
		    while (1) {
			token = advancetoken(flib, 0);
			if (token == NULL) break;
			if (!strcmp(token, ";")) break;
			if (!strcmp(token, "\""))
			    token = advancetoken(flib, '\"');
			if (!strcmp(token, "{")) {
			    token = advancetoken(flib, '}');
			    break;
			}
		    }
		}
		break;
	}
	token = advancetoken(flib, 0);
    }
}

/*--------------------------------------------------------------*/
/* Read a verilog netlist and collect information about the	*/
/* cells instantiated and the network structure			*/
/*--------------------------------------------------------------*/

void
verilogRead(FILE *fsrc, cell *cells, net **netlist, instance **instlist,
		connect **inputlist, connect **outputlist)
{
    char *token;
    char *modname = NULL;
    int section = MODULE;

    instptr newinst;
    netptr newnet, testnet;
    cellptr testcell;
    connptr newconn, testconn;
    pinptr testpin;

    int vstart, vend, vtarget, isinput;

    /* Read tokens off of the line */
    token = advancetoken(fsrc, 0);

    while (token != NULL) {

	switch (section) {
	    case MODULE:
		if (!strcasecmp(token, "module")) {
		    token = advancetoken(fsrc, 0);
		    fprintf(stderr, "Parsing module \"%s\"\n", token);

		    token = advancetoken(fsrc, 0);
		    if (strcmp(token, "("))
			fprintf(stderr, "Module not followed by pin list\n");
		    else
			token = advancetoken(fsrc, ')');
		    token = advancetoken(fsrc, ';');	// Get end-of-line

		    // Ignore the pin list, go straight to the input/output declarations
		    section = IOLIST;
		}
		break;

	    case IOLIST:
		if (!strcasecmp(token, "input") || !strcasecmp(token, "output")) {

		    testconn = NULL;
		    vstart = vend = 0;

		    if (!strcasecmp(token, "input")) {
			isinput = 1;
		    }
		    else { 	// output
			isinput = 0;
		    }

		    token = advancetoken(fsrc, 0);
		    if (*token == '[') {
			sscanf(token + 1, "%d", &vstart);
			token = advancetoken(fsrc, ':');
			token = advancetoken(fsrc, ']');	// Read to end of vector
			sscanf(token, "%d", &vend);
			token = advancetoken(fsrc, 0);		// Read signal name
		    }

		    // Create a net entry for the input or output, add to the list of nets

		    if (vstart == 0 && vend == 0) {
			newnet = create_net(netlist);
			newnet->name = strdup(token);

			testconn = (connptr)malloc(sizeof(connect));
			testconn->refnet = newnet;
			testconn->refpin = NULL;	// No associated pin
			testconn->refinst = NULL;	// No associated instance

			if (isinput) {			// driver (input)
			    testconn->next = *inputlist;
			    *inputlist = testconn;
			}
			else {				// receiver (output)
			    testconn->next = *outputlist;
			    *outputlist = testconn;
			}
		    }
		    else {
			vtarget = vend + (vstart < vend) ? 1 : -1;
			while (vstart != vtarget) {
			    newnet = create_net(netlist);
			    newnet->name = (char *)malloc(strlen(token) + 6);
			    sprintf(newnet->name, "%s[%d]", token, vstart);

			    vstart += (vtarget > vend) ? 1 : -1;

			    testconn = (connptr)malloc(sizeof(connect));
			    testconn->refnet = newnet;
			    testconn->refpin = NULL;	// No associated pin
			    testconn->refinst = NULL;	// No associated instance

			    if (isinput) {		// driver (input)
				testconn->next = *inputlist;
				*inputlist = testconn;
			    }
			    else {			// receiver (output)
				testconn->next = *outputlist;
				*outputlist = testconn;
			    }
			}
		    }
		    token = advancetoken(fsrc, ';');	// Get rest of input/output entry
		    break;
		}

		/* Drop through on anything that isn't an input, output, or blank line */

	    case GATELIST:

		if (!strcasecmp(token, "endmodule")) {
		    section = MODULE;
		    break;    
		}

		/* Confirm that the token is a known cell, and continue parsing line if so */
		/* Otherwise, parse to semicolon line end and continue */

		for (testcell = cells; testcell; testcell = testcell->next)
		    if (!strcasecmp(testcell->name, token))
			break;

		if (testcell != NULL) {
		    section = INSTANCE;
		    newinst = (instptr)malloc(sizeof(instance));
		    newinst->next = *instlist;
		    *instlist = newinst;
		    newinst->refcell = testcell;
		    newinst->in_connects = NULL;
		    newinst->out_connects = NULL;
		}
		else {
		    token = advancetoken(fsrc, ';');	// Get rest of entry, and ignore
		}
		break;

	    case INSTANCE:
		newinst->name = strdup(token);
		token = advancetoken(fsrc, '(');	// Find beginning of pin list
		section = INSTPIN;
		break;

	    case INSTPIN:
		if (*token == '.') {
		    newconn = (connptr)malloc(sizeof(connect));
		    // Pin name is in (token + 1)
		    for (testpin = testcell->pins; testpin; testpin = testpin->next) {
			if (!strcmp(testpin->name, token + 1))
			    break;
		    }
		    // Sanity check
		    if (testpin == NULL) {
			fprintf(stderr, "No such pin \"%s\" in cell \"%s\"!\n",
				token + 1, testcell->name);
		    }
		    else {
			if (testpin->type & OUTPUT) {
			    newconn->next = newinst->out_connects;
			    newinst->out_connects = newconn;
			}
			else {
			    newconn->next = newinst->in_connects;
			    newinst->in_connects = newconn;
			}
		    }
		    newconn->refinst = newinst;
		    newconn->refpin = testpin;
		    newconn->refnet = NULL;
		    token = advancetoken(fsrc, '(');	// Read to beginning of pin name
		    section = PINCONN;
		}
		else if (*token == ';') {
		    // End of instance record
		    section = GATELIST;
		}
		else if (*token != ',' && *token != ')') {
		    fprintf(stderr, "Unexpected entry in instance pin connection list!\n");
		    token = advancetoken(fsrc, ';');	// Read to end-of-line
		    section = GATELIST;
		}
		break;

	    case PINCONN:
		// Token is net name
		for (testnet = *netlist; testnet; testnet = testnet->next) {
		    if (!strcmp(testnet->name, token))
			break;
		}
		if (testnet == NULL) {
		    // This is a new net, and we need to record it
		    newnet = create_net(netlist);
		    newnet->name = strdup(token);
		    newconn->refnet = newnet;
		}
		else
		    newconn->refnet = testnet;
		token = advancetoken(fsrc, ')');	// Read to end of pin name
		section = INSTPIN;
		break;
	}
	token = advancetoken(fsrc, 0);
    }
}

/*--------------------------------------------------------------*/
/* For each net, go through the list of receivers and add the	*/
/* contributions of each to the total load.  This is either	*/
/* the input pin capacitance, if the receiver is a pin, or the	*/
/* designated output load (given on the command line), if the	*/
/* receiver is an output pin.					*/
/*--------------------------------------------------------------*/

void
computeLoads(netptr netlist, double out_load)
{
    pinptr testpin;
    netptr testnet, driver;
    connptr testconn;
    int i;

    for (testnet = netlist; testnet; testnet = testnet->next) {
	for (i = 0; i < testnet->fanout; i++) {
	    testconn = testnet->receivers[i];
	    testpin = testconn->refpin;
	    if (testpin == NULL) {
		testnet->loadr += out_load;
		testnet->loadf += out_load;
	    }
	    else {
		testnet->loadr += testpin->capr;
		testnet->loadf += testpin->capf;
	    }
	}
    }
}

/*--------------------------------------------------------------*/
/* Assign types to each net.  This identifies which nets are	*/
/* clock inputs, which are latch enable inputs, and which are	*/
/* asynchronous set/reset inputs,.				*/
/*								*/
/* Whenever a clock net is found, add the pins to clockedlist	*/
/*--------------------------------------------------------------*/

void assign_net_types(netptr netlist, connptr *clockedlist)
{
    int i;
    netptr testnet;
    connptr testrcvr;
    pinptr testpin;
    connptr newclocked;

    for (testnet = netlist; testnet; testnet = testnet->next) {
	for (i = 0; i < testnet->fanout; i++) {
	    testrcvr = testnet->receivers[i];
	    testpin = testrcvr->refpin;
	    if (testpin == NULL)
		testnet->type |= OUTTERM;
	    else {
		switch (testpin->type & (DFFMASK | LATCHMASK)) {
		    case DFFCLK:
			testnet->type |= CLOCK;
			newclocked = (connptr)malloc(sizeof(connect));
			newclocked->refnet = testnet;
			newclocked->refpin = testpin;
			newclocked->refinst = testrcvr->refinst;
			newclocked->next = *clockedlist;
			*clockedlist = newclocked;
			break;
		    case DFFIN:
			testnet->type |= TERMINAL;
			break;
		    case DFFSET:
		    case DFFRST:
			testnet->type |= ASYNC;
			break;
		    case LATCHIN:
			testnet->type |= LATCHTERM;
			break;
		    case LATCHEN:
			testnet->type |= ENABLE;
			break;
		}
	    }
	}
    }
}

/*--------------------------------------------------------------*/
/* Create the links representing the netlist connections.	*/
/*								*/
/* The verilogRead() routine added all nets and instances, and	*/
/* for each instance, generated a list of net connections to	*/
/* each pin.  To make the netlist easily traversible, this	*/
/* routine does the following:					*/
/*								*/
/* For each instance, work through the list of pin		*/
/*	connections.  If the pin is an output, then add the	*/
/*	connection as the net's driver entry.  If the pin is	*/
/*	an input, then add the connection to the list of the	*/
/*	net's receivers, and increment the net's fanout.	*/
/*								*/
/* For each module input, add the input connection as the	*/
/*	net's driver (flag an error if the net already has a	*/
/*	driver).						*/
/*								*/
/* For each module output, add the output connection as one of	*/
/*	the net's receivers (it may be the only one).		*/
/*								*/
/*--------------------------------------------------------------*/

void
createLinks(netptr netlist, instptr instlist, connptr inputlist, connptr outputlist)
{
    netptr testnet;
    instptr testinst;
    connptr testconn;

    for (testinst = instlist; testinst; testinst = testinst->next) {
	for (testconn = testinst->in_connects; testconn; testconn = testconn->next) {
	    testnet = testconn->refnet;
	    testnet->fanout++;
	    if (testnet->receivers == NULL)
		testnet->receivers = (connptr *)malloc(sizeof(connptr));

	    else
		testnet->receivers = (connptr *)realloc(testnet->receivers,
				testnet->fanout * sizeof(connptr));

	    testnet->receivers[testnet->fanout - 1] = testconn;
	} 

	for (testconn = testinst->out_connects; testconn; testconn = testconn->next) {
	    testnet = testconn->refnet;
	    testnet->driver = testconn;
	} 
    }

    for (testconn = inputlist; testconn; testconn = testconn->next) {
	testnet = testconn->refnet;
	if (testnet->driver != NULL)
	    fprintf(stderr, "Error:  Input pin \"%s\" has an internal driver!\n",
			testnet->name);
	else
	    testnet->driver = testconn;
    }

    for (testconn = outputlist; testconn; testconn = testconn->next) {
	testnet = testconn->refnet;
	testnet->fanout++;
	if (testnet->receivers == NULL)
	    testnet->receivers = (connptr *)malloc(sizeof(connptr));

	else 
	    testnet->receivers = (connptr *)realloc(testnet->receivers,
			testnet->fanout * sizeof(connptr));

	testnet->receivers[testnet->fanout - 1] = testconn;
    }
}

/*--------------------------------------------------------------*/
/* Main program							*/
/*--------------------------------------------------------------*/

int
main(int objc, char *argv[])
{
    FILE *flib;
    FILE *fsrc;
    double period = 0.0;
    double outLoad = 0.0;
    char *delayfile = NULL;
    int verbose = 0;
    int firstarg = 1;

    // Liberty database

    lutable *tables = NULL;
    cell *cells = NULL;

    // Verilog netlist database

    instptr instlist = NULL;
    netptr netlist = NULL;
    connptr clocklist = NULL;
    connptr inputlist = NULL;
    connptr outputlist = NULL;

    while ((firstarg < objc) && (*argv[firstarg] == '-')) {
       if (!strcmp(argv[firstarg], "-d") || !strcmp(argv[firstarg], "--delay")) {
	  delayfile = strdup(argv[firstarg + 1]);
	  firstarg += 2;
       }
       else if (!strcmp(argv[firstarg], "-p") || !strcmp(argv[firstarg], "--period")) {
	  period = strtod(argv[firstarg + 1], NULL);
	  firstarg += 2;
       }
       else if (!strcmp(argv[firstarg], "-l") || !strcmp(argv[firstarg], "--load")) {
	  outLoad = strtod(argv[firstarg + 1], NULL);
	  firstarg += 2;
       }
       else if (!strcmp(argv[firstarg], "-v") || !strcmp(argv[firstarg], "--verbose")) {
	  verbose = 1;
	  firstarg++;
       }
       else if (!strcmp(argv[firstarg], "--version")) {
	  fprintf(stderr, "Vesta Static Timing Analzyer version 0.1\n");
	  exit(0);
       }
       else {
	  fprintf(stderr, "Unknown option \"%s\"\n", argv[firstarg]);
	  firstarg++;
       }
    }

    if (objc - firstarg != 2) {
	fprintf(stderr, "Usage:  vesta [options] <name.v> <name.lib>\n");
	fprintf(stderr, "Options:\n");
	fprintf(stderr, "--delay <delay_file>	or	-d <delay_file>\n");
	fprintf(stderr, "--period <period>	or	-p <period>\n");
	fprintf(stderr, "--load <load>		or	-l <load>\n");
	fprintf(stderr, "--verbose		or	-v\n");
	fprintf(stderr, "--version\n");
	exit (1);
    }

    fsrc = fopen(argv[firstarg], "r");
    if (fsrc == NULL) {
	fprintf(stderr, "Cannot open %s for reading\n", argv[firstarg]);
	exit (1);
    }

    flib = fopen(argv[firstarg + 1], "r");
    if (flib == NULL) {
	fprintf(stderr, "Cannot open %s for reading\n", argv[firstarg + 1]);
	exit (1);
    }

    /*------------------------------------------------------------------*/
    /* Read the liberty format file.  This is not a rigorous parser!	*/
    /*------------------------------------------------------------------*/

    fileCurrentLine = 0;
    libertyRead(flib, &tables, &cells);
    fprintf(stdout, "Lib Read:  Processed %d lines.\n", fileCurrentLine);
    if (flib != NULL) fclose(flib);

    /*--------------------------------------------------*/
    /* Debug:  Print summary of liberty database	*/
    /*--------------------------------------------------*/

    if (verbose) {

	lutable *newtable;
	cell *newcell;
	pin *newpin;

	for (newtable = tables; newtable; newtable = newtable->next) {
	    fprintf(stdout, "Table: %s\n", newtable->name);
	}

	for (newcell = cells; newcell; newcell = newcell->next) {
	    fprintf(stdout, "Cell: %s\n", newcell->name);
	    fprintf(stdout, "   Function: %s\n", newcell->function);
	    for (newpin = newcell->pins; newpin; newpin = newpin->next) {
		if (newpin->type == INPUT)
		    fprintf(stdout, "   Pin: %s  cap=%g\n", newpin->name, newpin->capr);
	    }
	    fprintf(stdout, "\n");
	}
    }

    /*------------------------------------------------------------------*/
    /* Read verilog netlist.  This is also not a rigorous parser!	*/
    /*------------------------------------------------------------------*/

    fileCurrentLine = 0;
    verilogRead(fsrc, cells, &netlist, &instlist, &inputlist, &outputlist);
    fprintf(stdout, "Verilog netlist read:  Processed %d lines.\n", fileCurrentLine);
    if (fsrc != NULL) fclose(fsrc);

    /*--------------------------------------------------*/
    /* Debug:  Print summary of verilog source		*/
    /*--------------------------------------------------*/

    if (verbose) {
	connect *testoutput;
	connect *testinput;
	net *testnet;
	instance *testinst;

	for (testinput = inputlist; testinput; testinput = testinput->next) {
	    if (testinput->refnet)
		fprintf(stdout, "   Input: %s\n", testinput->refnet->name);
	}
	for (testoutput = outputlist; testoutput; testoutput = testoutput->next) {
	    if (testoutput->refnet)
		fprintf(stdout, "   Output: %s\n", testoutput->refnet->name);
	}
	for (testnet = netlist; testnet; testnet = testnet->next) {
	    fprintf(stdout, "   Net: %s\n", testnet->name);
	}
	for (testinst = instlist; testinst; testinst = testinst->next) {
	    fprintf(stdout, "   Gate: %s\n", testinst->name);
	}
    }

    /*--------------------------------------------------*/
    /* Generate internal links representing the network	*/
    /*--------------------------------------------------*/

    createLinks(netlist, instlist, inputlist, outputlist);

    /*--------------------------------------------------*/
    /* Calculate total load on each net			*/
    /* To do:  Add wire models or computed wire delays	*/
    /*--------------------------------------------------*/

    computeLoads(netlist, outLoad);

    /*--------------------------------------------------*/
    /* Assign net types, mainly to identify clocks	*/
    /* Return a list of clock nets			*/
    /*--------------------------------------------------*/

    assign_net_types(netlist, &clocklist);

    /*--------------------------------------------------*/
    /* Identify all clock-to-terminal paths		*/
    /*--------------------------------------------------*/

    find_clock_to_term_paths(clocklist);

    return 0;
}
